/* tslint:disable */
/* eslint-disable */
/**
 * Neynar API
 * The Neynar API allows you to interact with the Farcaster protocol among other things. See the [Neynar docs](https://docs.neynar.com/reference) for more details.
 *
 * The version of the OpenAPI document: 3.91.0
 * Contact: team@neynar.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { ErrorRes } from '../models';
// @ts-ignore
import type { FetchFeedForYou400Response } from '../models';
// @ts-ignore
import type { FetchRelevantFrames200Response } from '../models';
// @ts-ignore
import type { FrameCatalogResponse } from '../models';
// @ts-ignore
import type { FrameNotificationTokens } from '../models';
// @ts-ignore
import type { GetNotificationCampaignStats200Response } from '../models';
// @ts-ignore
import type { SendFrameNotificationsReqBody } from '../models';
// @ts-ignore
import type { SendFrameNotificationsResponse } from '../models';
// @ts-ignore
import type { TransactionFrameResponse } from '../models';
/**
 * FrameApi - axios parameter creator
 * @export
 */
export const FrameApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor 
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results 
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social 
         * @param {Array<FetchFrameCatalogNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         * 
         */
        fetchFrameCatalog: async (limit?: number, cursor?: string, timeWindow?: FetchFrameCatalogTimeWindowEnum, categories?: Array<FetchFrameCatalogCategoriesEnum>, networks?: Array<FetchFrameCatalogNetworksEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/farcaster/frame/catalog/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app. 
         * @param {string} [cursor] Pagination cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         * 
         */
        fetchNotificationTokens: async (limit?: number, fids?: string, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/farcaster/frame/notification_tokens/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for 
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance 
         * @param {Array<FetchRelevantFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         * 
         */
        fetchRelevantFrames: async (viewerFid: number, timeWindow?: FetchRelevantFramesTimeWindowEnum, networks?: Array<FetchRelevantFramesNetworksEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewerFid' is not null or undefined
            assertParamExists('fetchRelevantFrames', 'viewerFid', viewerFid)
            const localVarPath = `/v2/farcaster/frame/relevant/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (timeWindow !== undefined) {
                localVarQueryParameter['time_window'] = timeWindow;
            }

            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query 
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         * 
         */
        getNotificationCampaignStats: async (campaignId?: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         * 
         */
        getTransactionPayFrame: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getTransactionPayFrame', 'id', id)
            const localVarPath = `/v2/farcaster/frame/transaction/pay/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         * 
         */
        publishFrameNotifications: async (sendFrameNotificationsReqBody: SendFrameNotificationsReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendFrameNotificationsReqBody' is not null or undefined
            assertParamExists('publishFrameNotifications', 'sendFrameNotificationsReqBody', sendFrameNotificationsReqBody)
            const localVarPath = `/v2/farcaster/frame/notifications/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendFrameNotificationsReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps 
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor 
         * @param {Array<SearchFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         * 
         */
        searchFrames: async (q: string, limit?: number, cursor?: string, networks?: Array<SearchFramesNetworksEnum>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('searchFrames', 'q', q)
            const localVarPath = `/v2/farcaster/frame/search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (networks) {
                localVarQueryParameter['networks'] = networks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FrameApi - functional programming interface
 * @export
 */
export const FrameApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FrameApiAxiosParamCreator(configuration)
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {number} [limit] Number of results to fetch  (Default: 100, Maximum: 100)
         * @param {string} [cursor] Pagination cursor 
         * @param {FetchFrameCatalogTimeWindowEnum} [timeWindow] Time window used to calculate the change in trending score for each mini app, used to sort mini app results 
         * @param {Array<FetchFrameCatalogCategoriesEnum>} [categories] Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social 
         * @param {Array<FetchFrameCatalogNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         * 
         */
        async fetchFrameCatalog(limit?: number, cursor?: string, timeWindow?: FetchFrameCatalogTimeWindowEnum, categories?: Array<FetchFrameCatalogCategoriesEnum>, networks?: Array<FetchFrameCatalogNetworksEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrameCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchFrameCatalog(limit, cursor, timeWindow, categories, networks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.fetchFrameCatalog']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [fids] Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app. 
         * @param {string} [cursor] Pagination cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         * 
         */
        async fetchNotificationTokens(limit?: number, fids?: string, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrameNotificationTokens>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchNotificationTokens(limit, fids, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.fetchNotificationTokens']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {number} viewerFid FID of the user to fetch relevant mini apps for 
         * @param {FetchRelevantFramesTimeWindowEnum} [timeWindow] Time window used to limit statistics used to calculate mini app relevance 
         * @param {Array<FetchRelevantFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         * 
         */
        async fetchRelevantFrames(viewerFid: number, timeWindow?: FetchRelevantFramesTimeWindowEnum, networks?: Array<FetchRelevantFramesNetworksEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FetchRelevantFrames200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fetchRelevantFrames(viewerFid, timeWindow, networks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.fetchRelevantFrames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {string} [campaignId] An ID of a specific notification campaign to query 
         * @param {number} [limit] The number of results to return  (Default: 100, Maximum: 1000)
         * @param {string} [cursor] Pagination cursor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         * 
         */
        async getNotificationCampaignStats(campaignId?: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNotificationCampaignStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotificationCampaignStats(campaignId, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.getNotificationCampaignStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {string} id ID of the transaction mini app to retrieve 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         * 
         */
        async getTransactionPayFrame(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionFrameResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionPayFrame(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.getTransactionPayFrame']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {SendFrameNotificationsReqBody} sendFrameNotificationsReqBody  
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         * 
         */
        async publishFrameNotifications(sendFrameNotificationsReqBody: SendFrameNotificationsReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SendFrameNotificationsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publishFrameNotifications(sendFrameNotificationsReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.publishFrameNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {string} q Query string to search for mini apps 
         * @param {number} [limit] Number of results to fetch  (Default: 20, Maximum: 100)
         * @param {string} [cursor] Pagination cursor 
         * @param {Array<SearchFramesNetworksEnum>} [networks] List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         * 
         */
        async searchFrames(q: string, limit?: number, cursor?: string, networks?: Array<SearchFramesNetworksEnum>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrameCatalogResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchFrames(q, limit, cursor, networks, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FrameApi.searchFrames']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FrameApi - factory interface
 * @export
 */
export const FrameApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FrameApiFp(configuration)
    return {
        /**
         * A curated list of featured mini apps
         * @summary Mini apps catalog
         * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
         * 
         */
        fetchFrameCatalog(requestParameters: FrameApiFetchFrameCatalogRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<FrameCatalogResponse> {
            return localVarFp.fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of notifications tokens related to a mini app
         * @summary List of mini app notification tokens
         * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
         * 
         */
        fetchNotificationTokens(requestParameters: FrameApiFetchNotificationTokensRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<FrameNotificationTokens> {
            return localVarFp.fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
         * @summary Relevant mini apps
         * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
         * 
         */
        fetchRelevantFrames(requestParameters: FrameApiFetchRelevantFramesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FetchRelevantFrames200Response> {
            return localVarFp.fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve notification delivery and opened stats for notification campaigns
         * @summary Get notification campaign stats
         * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
         * 
         */
        getNotificationCampaignStats(requestParameters: FrameApiGetNotificationCampaignStatsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetNotificationCampaignStats200Response> {
            return localVarFp.getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves details about a transaction pay mini app by ID
         * @summary Get transaction pay mini app
         * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
         * 
         */
        getTransactionPayFrame(requestParameters: FrameApiGetTransactionPayFrameRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionFrameResponse> {
            return localVarFp.getTransactionPayFrame(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Send notifications to interactors of a mini app
         * @summary Send notifications
         * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
         * 
         */
        publishFrameNotifications(requestParameters: FrameApiPublishFrameNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SendFrameNotificationsResponse> {
            return localVarFp.publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for mini apps based on a query string
         * @summary Search mini apps
         * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
         * 
         * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
         * 
         */
        searchFrames(requestParameters: FrameApiSearchFramesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FrameCatalogResponse> {
            return localVarFp.searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, requestParameters.networks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FrameApi - interface
 * @export
 * @interface FrameApi
 */
export interface FrameApiInterface {
    /**
     * A curated list of featured mini apps
     * @summary Mini apps catalog
     * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
     * 
     */
    fetchFrameCatalog(requestParameters?: FrameApiFetchFrameCatalogRequest, options?: RawAxiosRequestConfig): AxiosPromise<FrameCatalogResponse>;

    /**
     * Returns a list of notifications tokens related to a mini app
     * @summary List of mini app notification tokens
     * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
     * 
     */
    fetchNotificationTokens(requestParameters?: FrameApiFetchNotificationTokensRequest, options?: RawAxiosRequestConfig): AxiosPromise<FrameNotificationTokens>;

    /**
     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
     * @summary Relevant mini apps
     * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
     * 
     */
    fetchRelevantFrames(requestParameters: FrameApiFetchRelevantFramesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FetchRelevantFrames200Response>;

    /**
     * Retrieve notification delivery and opened stats for notification campaigns
     * @summary Get notification campaign stats
     * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
     * 
     */
    getNotificationCampaignStats(requestParameters?: FrameApiGetNotificationCampaignStatsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetNotificationCampaignStats200Response>;

    /**
     * Retrieves details about a transaction pay mini app by ID
     * @summary Get transaction pay mini app
     * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
     * 
     */
    getTransactionPayFrame(requestParameters: FrameApiGetTransactionPayFrameRequest, options?: RawAxiosRequestConfig): AxiosPromise<TransactionFrameResponse>;

    /**
     * Send notifications to interactors of a mini app
     * @summary Send notifications
     * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
     * 
     */
    publishFrameNotifications(requestParameters: FrameApiPublishFrameNotificationsRequest, options?: RawAxiosRequestConfig): AxiosPromise<SendFrameNotificationsResponse>;

    /**
     * Search for mini apps based on a query string
     * @summary Search mini apps
     * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApiInterface
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
     * 
     */
    searchFrames(requestParameters: FrameApiSearchFramesRequest, options?: RawAxiosRequestConfig): AxiosPromise<FrameCatalogResponse>;

}

/**
 * Request parameters for fetchFrameCatalog operation in FrameApi.
 * @export
 * @interface FrameApiFetchFrameCatalogRequest
 */
export interface FrameApiFetchFrameCatalogRequest {
    /**
     * Number of results to fetch (Default: 100, Maximum: 100)
     * 
     * 
     * 
     * @type {number}
     * @memberof FrameApiFetchFrameCatalog
     */
    readonly limit?: number

    /**
     * Pagination cursor
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiFetchFrameCatalog
     */
    readonly cursor?: string

    /**
     * Time window used to calculate the change in trending score for each mini app, used to sort mini app results
     * 
     * 
     * 
     * @type {'1h' | '6h' | '12h' | '24h' | '7d'}
     * @memberof FrameApiFetchFrameCatalog
     */
    readonly timeWindow?: FetchFrameCatalogTimeWindowEnum

    /**
     * Comma separated list of categories to include in the results. Includes all if left blank. Example: categories&#x3D;games,social OR categories&#x3D;games&amp;categories&#x3D;social
     * 
     * 
     * 
     * @type {Array<'games' | 'social' | 'finance' | 'utility' | 'productivity' | 'health-fitness' | 'news-media' | 'music' | 'shopping' | 'education' | 'developer-tools' | 'entertainment' | 'art-creativity'>}
     * @memberof FrameApiFetchFrameCatalog
     */
    readonly categories?: Array<FetchFrameCatalogCategoriesEnum>

    /**
     * List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
     * 
     * 
     * 
     * @type {Array<'ethereum' | 'base' | 'arbitrum' | 'arbitrum-sepolia' | 'base-sepolia' | 'degen' | 'gnosis' | 'optimism' | 'optimism-sepolia' | 'polygon' | 'ethereum-sepolia' | 'zora' | 'unichain' | 'monad-testnet' | 'celo' | 'solana'>}
     * @memberof FrameApiFetchFrameCatalog
     */
    readonly networks?: Array<FetchFrameCatalogNetworksEnum>
}

/**
 * Request parameters for fetchNotificationTokens operation in FrameApi.
 * @export
 * @interface FrameApiFetchNotificationTokensRequest
 */
export interface FrameApiFetchNotificationTokensRequest {
    /**
     * Number of results to fetch (Default: 20, Maximum: 100)
     * 
     * 
     * 
     * @type {number}
     * @memberof FrameApiFetchNotificationTokens
     */
    readonly limit?: number

    /**
     * Comma separated list of FIDs, up to 100 at a time. If you pass in FIDs, you will get back the notification tokens for those FIDs. If you don\&#39;t pass in FIDs, you will get back all the notification tokens for the mini app.
     * @acceptAs integer
     * @commaSeparated
     * 
     * @type {string}
     * @memberof FrameApiFetchNotificationTokens
     */
    readonly fids?: string

    /**
     * Pagination cursor
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiFetchNotificationTokens
     */
    readonly cursor?: string
}

/**
 * Request parameters for fetchRelevantFrames operation in FrameApi.
 * @export
 * @interface FrameApiFetchRelevantFramesRequest
 */
export interface FrameApiFetchRelevantFramesRequest {
    /**
     * FID of the user to fetch relevant mini apps for
     * 
     * 
     * 
     * @type {number}
     * @memberof FrameApiFetchRelevantFrames
     */
    readonly viewerFid: number

    /**
     * Time window used to limit statistics used to calculate mini app relevance
     * 
     * 
     * 
     * @type {'1h' | '6h' | '12h' | '24h' | '7d'}
     * @memberof FrameApiFetchRelevantFrames
     */
    readonly timeWindow?: FetchRelevantFramesTimeWindowEnum

    /**
     * List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
     * 
     * 
     * 
     * @type {Array<'ethereum' | 'base' | 'arbitrum' | 'arbitrum-sepolia' | 'base-sepolia' | 'degen' | 'gnosis' | 'optimism' | 'optimism-sepolia' | 'polygon' | 'ethereum-sepolia' | 'zora' | 'unichain' | 'monad-testnet' | 'celo' | 'solana'>}
     * @memberof FrameApiFetchRelevantFrames
     */
    readonly networks?: Array<FetchRelevantFramesNetworksEnum>
}

/**
 * Request parameters for getNotificationCampaignStats operation in FrameApi.
 * @export
 * @interface FrameApiGetNotificationCampaignStatsRequest
 */
export interface FrameApiGetNotificationCampaignStatsRequest {
    /**
     * An ID of a specific notification campaign to query
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiGetNotificationCampaignStats
     */
    readonly campaignId?: string

    /**
     * The number of results to return (Default: 100, Maximum: 1000)
     * 
     * 
     * 
     * @type {number}
     * @memberof FrameApiGetNotificationCampaignStats
     */
    readonly limit?: number

    /**
     * Pagination cursor
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiGetNotificationCampaignStats
     */
    readonly cursor?: string
}

/**
 * Request parameters for getTransactionPayFrame operation in FrameApi.
 * @export
 * @interface FrameApiGetTransactionPayFrameRequest
 */
export interface FrameApiGetTransactionPayFrameRequest {
    /**
     * ID of the transaction mini app to retrieve
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiGetTransactionPayFrame
     */
    readonly id: string
}

/**
 * Request parameters for publishFrameNotifications operation in FrameApi.
 * @export
 * @interface FrameApiPublishFrameNotificationsRequest
 */
export interface FrameApiPublishFrameNotificationsRequest {
    /**
     * 
     * 
     * 
     * 
     * @type {SendFrameNotificationsReqBody}
     * @memberof FrameApiPublishFrameNotifications
     */
    readonly sendFrameNotificationsReqBody: SendFrameNotificationsReqBody
}

/**
 * Request parameters for searchFrames operation in FrameApi.
 * @export
 * @interface FrameApiSearchFramesRequest
 */
export interface FrameApiSearchFramesRequest {
    /**
     * Query string to search for mini apps
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiSearchFrames
     */
    readonly q: string

    /**
     * Number of results to fetch (Default: 20, Maximum: 100)
     * 
     * 
     * 
     * @type {number}
     * @memberof FrameApiSearchFrames
     */
    readonly limit?: number

    /**
     * Pagination cursor
     * 
     * 
     * 
     * @type {string}
     * @memberof FrameApiSearchFrames
     */
    readonly cursor?: string

    /**
     * List of blockchain networks by which to filter results.  Mini apps included in the results will specify at least one of the supplied networks or specify none. The list can be provided as comma-separated string or array.
     * 
     * 
     * 
     * @type {Array<'ethereum' | 'base' | 'arbitrum' | 'arbitrum-sepolia' | 'base-sepolia' | 'degen' | 'gnosis' | 'optimism' | 'optimism-sepolia' | 'polygon' | 'ethereum-sepolia' | 'zora' | 'unichain' | 'monad-testnet' | 'celo' | 'solana'>}
     * @memberof FrameApiSearchFrames
     */
    readonly networks?: Array<SearchFramesNetworksEnum>
}

/**
 * FrameApi - object-oriented interface
 * @export
 * @class FrameApi
 * @extends {BaseAPI}
 */
export class FrameApi extends BaseAPI implements FrameApiInterface {
    /**
     * A curated list of featured mini apps
     * @summary Mini apps catalog
     * @param {FrameApiFetchFrameCatalogRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-frame-catalog)
     * 
     */
    public fetchFrameCatalog(requestParameters: FrameApiFetchFrameCatalogRequest = {}, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).fetchFrameCatalog(requestParameters.limit, requestParameters.cursor, requestParameters.timeWindow, requestParameters.categories, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of notifications tokens related to a mini app
     * @summary List of mini app notification tokens
     * @param {FrameApiFetchNotificationTokensRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameNotificationTokens>} A promise that resolves to a `FrameNotificationTokens` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-notification-tokens)
     * 
     */
    public fetchNotificationTokens(requestParameters: FrameApiFetchNotificationTokensRequest = {}, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).fetchNotificationTokens(requestParameters.limit, requestParameters.fids, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of mini apps relevant to the user based on casts by users with strong affinity score for the user
     * @summary Relevant mini apps
     * @param {FrameApiFetchRelevantFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FetchRelevantFrames200Response>} A promise that resolves to a `FetchRelevantFrames200Response` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/fetch-relevant-frames)
     * 
     */
    public fetchRelevantFrames(requestParameters: FrameApiFetchRelevantFramesRequest, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).fetchRelevantFrames(requestParameters.viewerFid, requestParameters.timeWindow, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve notification delivery and opened stats for notification campaigns
     * @summary Get notification campaign stats
     * @param {FrameApiGetNotificationCampaignStatsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<GetNotificationCampaignStats200Response>} A promise that resolves to a `GetNotificationCampaignStats200Response` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-notification-campaign-stats)
     * 
     */
    public getNotificationCampaignStats(requestParameters: FrameApiGetNotificationCampaignStatsRequest = {}, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).getNotificationCampaignStats(requestParameters.campaignId, requestParameters.limit, requestParameters.cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves details about a transaction pay mini app by ID
     * @summary Get transaction pay mini app
     * @param {FrameApiGetTransactionPayFrameRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<TransactionFrameResponse>} A promise that resolves to a `TransactionFrameResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/get-transaction-pay-frame)
     * 
     */
    public getTransactionPayFrame(requestParameters: FrameApiGetTransactionPayFrameRequest, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).getTransactionPayFrame(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send notifications to interactors of a mini app
     * @summary Send notifications
     * @param {FrameApiPublishFrameNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<SendFrameNotificationsResponse>} A promise that resolves to a `SendFrameNotificationsResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/publish-frame-notifications)
     * 
     */
    public publishFrameNotifications(requestParameters: FrameApiPublishFrameNotificationsRequest, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).publishFrameNotifications(requestParameters.sendFrameNotificationsReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for mini apps based on a query string
     * @summary Search mini apps
     * @param {FrameApiSearchFramesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FrameApi
     * @returns {Promise<FrameCatalogResponse>} A promise that resolves to a `FrameCatalogResponse` object
     * 
     * For more information, refer to the [API documentation](https://docs.neynar.com/reference/search-frames)
     * 
     */
    public searchFrames(requestParameters: FrameApiSearchFramesRequest, options?: RawAxiosRequestConfig) {
        return FrameApiFp(this.configuration).searchFrames(requestParameters.q, requestParameters.limit, requestParameters.cursor, requestParameters.networks, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FetchFrameCatalogTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
} as const;
export type FetchFrameCatalogTimeWindowEnum = typeof FetchFrameCatalogTimeWindowEnum[keyof typeof FetchFrameCatalogTimeWindowEnum];
/**
 * @export
 */
export const FetchFrameCatalogCategoriesEnum = {
    Games: 'games',
    Social: 'social',
    Finance: 'finance',
    Utility: 'utility',
    Productivity: 'productivity',
    HealthFitness: 'health-fitness',
    NewsMedia: 'news-media',
    Music: 'music',
    Shopping: 'shopping',
    Education: 'education',
    DeveloperTools: 'developer-tools',
    Entertainment: 'entertainment',
    ArtCreativity: 'art-creativity'
} as const;
export type FetchFrameCatalogCategoriesEnum = typeof FetchFrameCatalogCategoriesEnum[keyof typeof FetchFrameCatalogCategoriesEnum];
/**
 * @export
 */
export const FetchFrameCatalogNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
} as const;
export type FetchFrameCatalogNetworksEnum = typeof FetchFrameCatalogNetworksEnum[keyof typeof FetchFrameCatalogNetworksEnum];
/**
 * @export
 */
export const FetchRelevantFramesTimeWindowEnum = {
    _1h: '1h',
    _6h: '6h',
    _12h: '12h',
    _24h: '24h',
    _7d: '7d'
} as const;
export type FetchRelevantFramesTimeWindowEnum = typeof FetchRelevantFramesTimeWindowEnum[keyof typeof FetchRelevantFramesTimeWindowEnum];
/**
 * @export
 */
export const FetchRelevantFramesNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
} as const;
export type FetchRelevantFramesNetworksEnum = typeof FetchRelevantFramesNetworksEnum[keyof typeof FetchRelevantFramesNetworksEnum];
/**
 * @export
 */
export const SearchFramesNetworksEnum = {
    Ethereum: 'ethereum',
    Base: 'base',
    Arbitrum: 'arbitrum',
    ArbitrumSepolia: 'arbitrum-sepolia',
    BaseSepolia: 'base-sepolia',
    Degen: 'degen',
    Gnosis: 'gnosis',
    Optimism: 'optimism',
    OptimismSepolia: 'optimism-sepolia',
    Polygon: 'polygon',
    EthereumSepolia: 'ethereum-sepolia',
    Zora: 'zora',
    Unichain: 'unichain',
    MonadTestnet: 'monad-testnet',
    Celo: 'celo',
    Solana: 'solana'
} as const;
export type SearchFramesNetworksEnum = typeof SearchFramesNetworksEnum[keyof typeof SearchFramesNetworksEnum];
