/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { AddVerificationReqBody } from '../models';
// @ts-ignore
import { BulkFollowResponse } from '../models';
// @ts-ignore
import { BulkUsersResponse } from '../models';
// @ts-ignore
import { ConflictErrorRes } from '../models';
// @ts-ignore
import { ErrorRes } from '../models';
// @ts-ignore
import { FollowReqBody } from '../models';
// @ts-ignore
import { OperationResponse } from '../models';
// @ts-ignore
import { RegisterUserReqBody } from '../models';
// @ts-ignore
import { RegisterUserResponse } from '../models';
// @ts-ignore
import { RemoveVerificationReqBody } from '../models';
// @ts-ignore
import { UpdateUserReqBody } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { UserFIDResponse } from '../models';
// @ts-ignore
import { UserPowerLiteResponse } from '../models';
// @ts-ignore
import { UserResponse } from '../models';
// @ts-ignore
import { UserSearchResponse } from '../models';
// @ts-ignore
import { UsersResponse } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers: async (apiKey: string, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('activeUsers', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete: async (apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('farcasterUserVerificationDelete', 'apiKey', apiKey)
            // verify required parameter 'removeVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationDelete', 'removeVerificationReqBody', removeVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Adds verification for an ethereum address or contract for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost: async (apiKey: string, addVerificationReqBody: AddVerificationReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('farcasterUserVerificationPost', 'apiKey', apiKey)
            // verify required parameter 'addVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationPost', 'addVerificationReqBody', addVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (apiKey: string, followReqBody: FollowReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('followUser', 'apiKey', apiKey)
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('followUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid: async (apiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getFreshFid', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/fid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress: async (apiKey: string, custodyAddress: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('lookupUserByCustodyAddress', 'apiKey', apiKey)
            // verify required parameter 'custodyAddress' is not null or undefined
            assertParamExists('lookupUserByCustodyAddress', 'custodyAddress', custodyAddress)
            const localVarPath = `/farcaster/user/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (custodyAddress !== undefined) {
                localVarQueryParameter['custody_address'] = custodyAddress;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Fetch power user objects
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers: async (apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('powerUsers', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/power`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch fid API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this fid to another available user. 
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (apiKey: string, registerUserReqBody: RegisterUserReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('registerUser', 'apiKey', apiKey)
            // verify required parameter 'registerUserReqBody' is not null or undefined
            assertParamExists('registerUser', 'registerUserReqBody', registerUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (apiKey: string, followReqBody: FollowReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('unfollowUser', 'apiKey', apiKey)
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('unfollowUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (apiKey: string, updateUserReqBody: UpdateUserReqBody, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('updateUser', 'apiKey', apiKey)
            // verify required parameter 'updateUserReqBody' is not null or undefined
            assertParamExists('updateUser', 'updateUserReqBody', updateUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk: async (apiKey: string, fids: string, viewerFid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userBulk', 'apiKey', apiKey)
            // verify required parameter 'fids' is not null or undefined
            assertParamExists('userBulk', 'fids', fids)
            const localVarPath = `/farcaster/user/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress: async (apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userBulkByAddress', 'apiKey', apiKey)
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('userBulkByAddress', 'addresses', addresses)
            const localVarPath = `/farcaster/user/bulk-by-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }

            if (addressTypes !== undefined) {
                localVarQueryParameter['address_types'] = addressTypes;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Fetch power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite: async (apiKey: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userPowerLite', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/power_lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] 
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userSearch', 'apiKey', apiKey)
            // verify required parameter 'q' is not null or undefined
            assertParamExists('userSearch', 'q', q)
            const localVarPath = `/farcaster/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async activeUsers(apiKey: string, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeUsers(apiKey, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Adds verification for an ethereum address or contract for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(apiKey: string, followReqBody: FollowReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(apiKey, followReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreshFid(apiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFIDResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshFid(apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(apiKey, custodyAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Fetch power user objects
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.powerUsers(apiKey, viewerFid, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch fid API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this fid to another available user. 
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(apiKey, registerUserReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(apiKey, followReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(apiKey, updateUserReqBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulk(apiKey: string, fids: string, viewerFid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulk(apiKey, fids, viewerFid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<User>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Fetch power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPowerLite(apiKey: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPowerLiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPowerLite(apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] 
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(apiKey, q, viewerFid, limit, cursor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers(apiKey: string, limit?: number, cursor?: string, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.activeUsers(apiKey, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Removes verification for an eth address for the user
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Adds verification for an ethereum address or contract for the user
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(apiKey: string, followReqBody: FollowReqBody, options?: any): AxiosPromise<BulkFollowResponse> {
            return localVarFp.followUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches fid to assign it new user
         * @summary Fetches fid to assign it new user
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid(apiKey: string, options?: any): AxiosPromise<UserFIDResponse> {
            return localVarFp.getFreshFid(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup a user by custody-address
         * @summary Lookup a user by custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: any): AxiosPromise<UserResponse> {
            return localVarFp.lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Fetch power user objects
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: any): AxiosPromise<UsersResponse> {
            return localVarFp.powerUsers(apiKey, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch fid API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this fid to another available user. 
         * @summary Register account on farcaster
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: any): AxiosPromise<RegisterUserResponse> {
            return localVarFp.registerUser(apiKey, registerUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow a user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: any): AxiosPromise<BulkFollowResponse> {
            return localVarFp.unfollowUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: any): AxiosPromise<OperationResponse> {
            return localVarFp.updateUser(apiKey, updateUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary Fetch users based on FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk(apiKey: string, fids: string, viewerFid?: number, options?: any): AxiosPromise<BulkUsersResponse> {
            return localVarFp.userBulk(apiKey, fids, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary Fetches users based on Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: any): AxiosPromise<{ [key: string]: Array<User>; }> {
            return localVarFp.userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Fetch power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite(apiKey: string, options?: any): AxiosPromise<UserPowerLiteResponse> {
            return localVarFp.userPowerLite(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] 
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: any): AxiosPromise<UserSearchResponse> {
            return localVarFp.userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Warpcast has deprecated the active badge. Use user/power endpoint instead.
     * @summary Fetch active users
     * @param {string} apiKey API key required for authentication.
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public activeUsers(apiKey: string, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).activeUsers(apiKey, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
     * @summary Removes verification for an eth address for the user
     * @param {string} apiKey API key required for authentication.
     * @param {RemoveVerificationReqBody} removeVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
     * @summary Adds verification for an ethereum address or contract for the user
     * @param {string} apiKey API key required for authentication.
     * @param {AddVerificationReqBody} addVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
     * @summary Follow a user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public followUser(apiKey: string, followReqBody: FollowReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).followUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches fid to assign it new user
     * @summary Fetches fid to assign it new user
     * @param {string} apiKey API key required for authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getFreshFid(apiKey: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getFreshFid(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lookup a user by custody-address
     * @summary Lookup a user by custody-address
     * @param {string} apiKey API key required for authentication.
     * @param {string} custodyAddress Custody Address associated with mnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users based on Warpcast power badges. Information is updated once a day.
     * @summary Fetch power user objects
     * @param {string} apiKey API key required for authentication.
     * @param {number} [viewerFid] 
     * @param {number} [limit] Number of power users to fetch, max 100
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).powerUsers(apiKey, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch fid API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this fid to another available user. 
     * @summary Register account on farcaster
     * @param {string} apiKey API key required for authentication.
     * @param {RegisterUserReqBody} registerUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).registerUser(apiKey, registerUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
     * @summary Unfollow a user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).unfollowUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
     * @summary Update user profile
     * @param {string} apiKey API key required for authentication.
     * @param {UpdateUserReqBody} updateUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(apiKey, updateUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches information about multiple users based on FIDs
     * @summary Fetch users based on FIDs
     * @param {string} apiKey API key required for authentication.
     * @param {string} fids Comma separated list of FIDs, up to 100 at a time
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulk(apiKey: string, fids: string, viewerFid?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulk(apiKey, fids, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     * @summary Fetches users based on Eth or Sol addresses
     * @param {string} apiKey API key required for authentication.
     * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
     * @summary Fetch power user FIDs
     * @param {string} apiKey API key required for authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPowerLite(apiKey: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userPowerLite(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for Usernames
     * @summary Search for Usernames
     * @param {string} apiKey API key required for authentication.
     * @param {string} q 
     * @param {number} [viewerFid] 
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}
