/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AddVerificationReqBody } from '../models';
// @ts-ignore
import type { BulkFollowResponse } from '../models';
// @ts-ignore
import type { BulkUsersResponse } from '../models';
// @ts-ignore
import type { ConflictErrorRes } from '../models';
// @ts-ignore
import type { ErrorRes } from '../models';
// @ts-ignore
import type { FollowReqBody } from '../models';
// @ts-ignore
import type { OperationResponse } from '../models';
// @ts-ignore
import type { RegisterUserReqBody } from '../models';
// @ts-ignore
import type { RegisterUserResponse } from '../models';
// @ts-ignore
import type { RemoveVerificationReqBody } from '../models';
// @ts-ignore
import type { UpdateUserReqBody } from '../models';
// @ts-ignore
import type { User } from '../models';
// @ts-ignore
import type { UserFIDResponse } from '../models';
// @ts-ignore
import type { UserPowerLiteResponse } from '../models';
// @ts-ignore
import type { UserResponse } from '../models';
// @ts-ignore
import type { UserSearchResponse } from '../models';
// @ts-ignore
import type { UsersResponse } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers: async (apiKey: string, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('activeUsers', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete: async (apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('farcasterUserVerificationDelete', 'apiKey', apiKey)
            // verify required parameter 'removeVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationDelete', 'removeVerificationReqBody', removeVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost: async (apiKey: string, addVerificationReqBody: AddVerificationReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('farcasterUserVerificationPost', 'apiKey', apiKey)
            // verify required parameter 'addVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationPost', 'addVerificationReqBody', addVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (apiKey: string, followReqBody: FollowReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('followUser', 'apiKey', apiKey)
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('followUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid: async (apiKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('getFreshFid', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/fid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress: async (apiKey: string, custodyAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('lookupUserByCustodyAddress', 'apiKey', apiKey)
            // verify required parameter 'custodyAddress' is not null or undefined
            assertParamExists('lookupUserByCustodyAddress', 'custodyAddress', custodyAddress)
            const localVarPath = `/farcaster/user/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (custodyAddress !== undefined) {
                localVarQueryParameter['custody_address'] = custodyAddress;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers: async (apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('powerUsers', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/power`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (apiKey: string, registerUserReqBody: RegisterUserReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('registerUser', 'apiKey', apiKey)
            // verify required parameter 'registerUserReqBody' is not null or undefined
            assertParamExists('registerUser', 'registerUserReqBody', registerUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (apiKey: string, followReqBody: FollowReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('unfollowUser', 'apiKey', apiKey)
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('unfollowUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (apiKey: string, updateUserReqBody: UpdateUserReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('updateUser', 'apiKey', apiKey)
            // verify required parameter 'updateUserReqBody' is not null or undefined
            assertParamExists('updateUser', 'updateUserReqBody', updateUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk: async (apiKey: string, fids: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userBulk', 'apiKey', apiKey)
            // verify required parameter 'fids' is not null or undefined
            assertParamExists('userBulk', 'fids', fids)
            const localVarPath = `/farcaster/user/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress: async (apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userBulkByAddress', 'apiKey', apiKey)
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('userBulkByAddress', 'addresses', addresses)
            const localVarPath = `/farcaster/user/bulk-by-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }

            if (addressTypes !== undefined) {
                localVarQueryParameter['address_types'] = addressTypes;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} apiKey API key required for authentication.
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByUsernameV2: async (apiKey: string, username: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userByUsernameV2', 'apiKey', apiKey)
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userByUsernameV2', 'username', username)
            const localVarPath = `/farcaster/user/by_username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite: async (apiKey: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userPowerLite', 'apiKey', apiKey)
            const localVarPath = `/farcaster/user/power_lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'apiKey' is not null or undefined
            assertParamExists('userSearch', 'apiKey', apiKey)
            // verify required parameter 'q' is not null or undefined
            assertParamExists('userSearch', 'q', q)
            const localVarPath = `/farcaster/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            if (apiKey != null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async activeUsers(apiKey: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeUsers(apiKey, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.activeUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.farcasterUserVerificationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.farcasterUserVerificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(apiKey, followReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.followUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreshFid(apiKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFIDResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshFid(apiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getFreshFid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(apiKey, custodyAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.lookupUserByCustodyAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.powerUsers(apiKey, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.powerUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(apiKey, registerUserReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(apiKey, followReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.unfollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(apiKey, updateUserReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulk(apiKey: string, fids: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulk(apiKey, fids, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<User>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userBulkByAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} apiKey API key required for authentication.
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userByUsernameV2(apiKey: string, username: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userByUsernameV2(apiKey, username, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userByUsernameV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPowerLite(apiKey: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPowerLiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPowerLite(apiKey, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userPowerLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(apiKey, q, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers(apiKey: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.activeUsers(apiKey, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {string} apiKey API key required for authentication.
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {string} apiKey API key required for authentication.
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): AxiosPromise<BulkFollowResponse> {
            return localVarFp.followUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid(apiKey: string, options?: RawAxiosRequestConfig): AxiosPromise<UserFIDResponse> {
            return localVarFp.getFreshFid(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} apiKey API key required for authentication.
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {string} apiKey API key required for authentication.
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.powerUsers(apiKey, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {string} apiKey API key required for authentication.
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig): AxiosPromise<RegisterUserResponse> {
            return localVarFp.registerUser(apiKey, registerUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {string} apiKey API key required for authentication.
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): AxiosPromise<BulkFollowResponse> {
            return localVarFp.unfollowUser(apiKey, followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {string} apiKey API key required for authentication.
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.updateUser(apiKey, updateUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk(apiKey: string, fids: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<BulkUsersResponse> {
            return localVarFp.userBulk(apiKey, fids, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} apiKey API key required for authentication.
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<User>; }> {
            return localVarFp.userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} apiKey API key required for authentication.
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByUsernameV2(apiKey: string, username: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.userByUsernameV2(apiKey, username, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {string} apiKey API key required for authentication.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite(apiKey: string, options?: RawAxiosRequestConfig): AxiosPromise<UserPowerLiteResponse> {
            return localVarFp.userPowerLite(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} apiKey API key required for authentication.
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSearchResponse> {
            return localVarFp.userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Warpcast has deprecated the active badge. Use user/power endpoint instead.
     * @summary Fetch active users
     * @param {string} apiKey API key required for authentication.
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public activeUsers(apiKey: string, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).activeUsers(apiKey, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
     * @summary Delete verification
     * @param {string} apiKey API key required for authentication.
     * @param {RemoveVerificationReqBody} removeVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationDelete(apiKey: string, removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationDelete(apiKey, removeVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
     * @summary Add verification
     * @param {string} apiKey API key required for authentication.
     * @param {AddVerificationReqBody} addVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationPost(apiKey: string, addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationPost(apiKey, addVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
     * @summary Follow user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public followUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).followUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
     * @summary Fetch fresh FID
     * @param {string} apiKey API key required for authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getFreshFid(apiKey: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getFreshFid(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lookup a user by custody-address
     * @summary By custody-address
     * @param {string} apiKey API key required for authentication.
     * @param {string} custodyAddress Custody Address associated with mnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public lookupUserByCustodyAddress(apiKey: string, custodyAddress: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).lookupUserByCustodyAddress(apiKey, custodyAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users based on Warpcast power badges. Information is updated once a day.
     * @summary Power users
     * @param {string} apiKey API key required for authentication.
     * @param {number} [viewerFid] 
     * @param {number} [limit] Number of power users to fetch, max 100
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public powerUsers(apiKey: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).powerUsers(apiKey, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
     * @summary Register new account
     * @param {string} apiKey API key required for authentication.
     * @param {RegisterUserReqBody} registerUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(apiKey: string, registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).registerUser(apiKey, registerUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
     * @summary Unfollow user
     * @param {string} apiKey API key required for authentication.
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public unfollowUser(apiKey: string, followReqBody: FollowReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).unfollowUser(apiKey, followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
     * @summary Update user profile
     * @param {string} apiKey API key required for authentication.
     * @param {UpdateUserReqBody} updateUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(apiKey: string, updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(apiKey, updateUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches information about multiple users based on FIDs
     * @summary By FIDs
     * @param {string} apiKey API key required for authentication.
     * @param {string} fids Comma separated list of FIDs, up to 100 at a time
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulk(apiKey: string, fids: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulk(apiKey, fids, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     * @summary By Eth or Sol addresses
     * @param {string} apiKey API key required for authentication.
     * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulkByAddress(apiKey: string, addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulkByAddress(apiKey, addresses, addressTypes, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single hydrated user object given a username
     * @summary By username
     * @param {string} apiKey API key required for authentication.
     * @param {string} username Username of the user to fetch
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userByUsernameV2(apiKey: string, username: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userByUsernameV2(apiKey, username, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
     * @summary Power user FIDs
     * @param {string} apiKey API key required for authentication.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPowerLite(apiKey: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userPowerLite(apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for Usernames
     * @summary Search for Usernames
     * @param {string} apiKey API key required for authentication.
     * @param {string} q 
     * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(apiKey: string, q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(apiKey, q, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}

