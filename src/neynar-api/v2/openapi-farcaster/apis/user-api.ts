/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AddVerificationReqBody } from '../models';
// @ts-ignore
import type { BulkFollowResponse } from '../models';
// @ts-ignore
import type { BulkUsersResponse } from '../models';
// @ts-ignore
import type { ConflictErrorRes } from '../models';
// @ts-ignore
import type { ErrorRes } from '../models';
// @ts-ignore
import type { FollowReqBody } from '../models';
// @ts-ignore
import type { OperationResponse } from '../models';
// @ts-ignore
import type { RegisterUserReqBody } from '../models';
// @ts-ignore
import type { RegisterUserResponse } from '../models';
// @ts-ignore
import type { RemoveVerificationReqBody } from '../models';
// @ts-ignore
import type { UpdateUserReqBody } from '../models';
// @ts-ignore
import type { User } from '../models';
// @ts-ignore
import type { UserFIDResponse } from '../models';
// @ts-ignore
import type { UserPowerLiteResponse } from '../models';
// @ts-ignore
import type { UserResponse } from '../models';
// @ts-ignore
import type { UserSearchResponse } from '../models';
// @ts-ignore
import type { UsersResponse } from '../models';
/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers: async (limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/user/active`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete: async (removeVerificationReqBody: RemoveVerificationReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'removeVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationDelete', 'removeVerificationReqBody', removeVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(removeVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost: async (addVerificationReqBody: AddVerificationReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addVerificationReqBody' is not null or undefined
            assertParamExists('farcasterUserVerificationPost', 'addVerificationReqBody', addVerificationReqBody)
            const localVarPath = `/farcaster/user/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addVerificationReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser: async (followReqBody: FollowReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('followUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/user/fid`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress: async (custodyAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'custodyAddress' is not null or undefined
            assertParamExists('lookupUserByCustodyAddress', 'custodyAddress', custodyAddress)
            const localVarPath = `/farcaster/user/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (custodyAddress !== undefined) {
                localVarQueryParameter['custody_address'] = custodyAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers: async (viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/user/power`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser: async (registerUserReqBody: RegisterUserReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerUserReqBody' is not null or undefined
            assertParamExists('registerUser', 'registerUserReqBody', registerUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser: async (followReqBody: FollowReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'followReqBody' is not null or undefined
            assertParamExists('unfollowUser', 'followReqBody', followReqBody)
            const localVarPath = `/farcaster/user/follow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserReqBody: UpdateUserReqBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserReqBody' is not null or undefined
            assertParamExists('updateUser', 'updateUserReqBody', updateUserReqBody)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserReqBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk: async (fids: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fids' is not null or undefined
            assertParamExists('userBulk', 'fids', fids)
            const localVarPath = `/farcaster/user/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fids !== undefined) {
                localVarQueryParameter['fids'] = fids;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress: async (addresses: string, addressTypes?: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('userBulkByAddress', 'addresses', addresses)
            const localVarPath = `/farcaster/user/bulk-by-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (addresses !== undefined) {
                localVarQueryParameter['addresses'] = addresses;
            }

            if (addressTypes !== undefined) {
                localVarQueryParameter['address_types'] = addressTypes;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {number} latitude Latitude of the location
         * @param {number} longitude Longitude of the location
         * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of results to fetch
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByLocation: async (latitude: number, longitude: number, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'latitude' is not null or undefined
            assertParamExists('userByLocation', 'latitude', latitude)
            // verify required parameter 'longitude' is not null or undefined
            assertParamExists('userByLocation', 'longitude', longitude)
            const localVarPath = `/farcaster/user/by_location`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByUsernameV2: async (username: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userByUsernameV2', 'username', username)
            const localVarPath = `/farcaster/user/by_username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/user/power_lite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch: async (q: string, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'q' is not null or undefined
            assertParamExists('userSearch', 'q', q)
            const localVarPath = `/farcaster/user/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewer_fid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async activeUsers(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.activeUsers(limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.activeUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationDelete(removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationDelete(removeVerificationReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.farcasterUserVerificationDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async farcasterUserVerificationPost(addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.farcasterUserVerificationPost(addVerificationReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.farcasterUserVerificationPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUser(followReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.followUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFreshFid(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFIDResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFreshFid(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.getFreshFid']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async lookupUserByCustodyAddress(custodyAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.lookupUserByCustodyAddress(custodyAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.lookupUserByCustodyAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async powerUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.powerUsers(viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.powerUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerUser(registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterUserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerUser(registerUserReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.registerUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unfollowUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkFollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unfollowUser(followReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.unfollowUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserReqBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulk(fids: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulk(fids, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userBulk']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userBulkByAddress(addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<User>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userBulkByAddress(addresses, addressTypes, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userBulkByAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {number} latitude Latitude of the location
         * @param {number} longitude Longitude of the location
         * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of results to fetch
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userByLocation(latitude: number, longitude: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userByLocation(latitude, longitude, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userByLocation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userByUsernameV2(username: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userByUsernameV2(username, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userByUsernameV2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userPowerLite(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPowerLiteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userPowerLite(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userPowerLite']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userSearch(q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userSearch(q, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userSearch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Warpcast has deprecated the active badge. Use user/power endpoint instead.
         * @summary Fetch active users
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        activeUsers(limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.activeUsers(limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
         * @summary Delete verification
         * @param {RemoveVerificationReqBody} removeVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationDelete(removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationDelete(removeVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
         * @summary Add verification
         * @param {AddVerificationReqBody} addVerificationReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        farcasterUserVerificationPost(addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.farcasterUserVerificationPost(addVerificationReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
         * @summary Follow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): AxiosPromise<BulkFollowResponse> {
            return localVarFp.followUser(followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
         * @summary Fetch fresh FID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFreshFid(options?: RawAxiosRequestConfig): AxiosPromise<UserFIDResponse> {
            return localVarFp.getFreshFid(options).then((request) => request(axios, basePath));
        },
        /**
         * Lookup a user by custody-address
         * @summary By custody-address
         * @param {string} custodyAddress Custody Address associated with mnemonic
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        lookupUserByCustodyAddress(custodyAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.lookupUserByCustodyAddress(custodyAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users based on Warpcast power badges. Information is updated once a day.
         * @summary Power users
         * @param {number} [viewerFid] 
         * @param {number} [limit] Number of power users to fetch, max 100
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        powerUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.powerUsers(viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
         * @summary Register new account
         * @param {RegisterUserReqBody} registerUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig): AxiosPromise<RegisterUserResponse> {
            return localVarFp.registerUser(registerUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
         * @summary Unfollow user
         * @param {FollowReqBody} followReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unfollowUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig): AxiosPromise<BulkFollowResponse> {
            return localVarFp.unfollowUser(followReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
         * @summary Update user profile
         * @param {UpdateUserReqBody} updateUserReqBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig): AxiosPromise<OperationResponse> {
            return localVarFp.updateUser(updateUserReqBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches information about multiple users based on FIDs
         * @summary By FIDs
         * @param {string} fids Comma separated list of FIDs, up to 100 at a time
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulk(fids: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<BulkUsersResponse> {
            return localVarFp.userBulk(fids, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
         * @summary By Eth or Sol addresses
         * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
         * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userBulkByAddress(addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<User>; }> {
            return localVarFp.userBulkByAddress(addresses, addressTypes, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of users given a location
         * @summary By location
         * @param {number} latitude Latitude of the location
         * @param {number} longitude Longitude of the location
         * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] Number of results to fetch
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByLocation(latitude: number, longitude: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UsersResponse> {
            return localVarFp.userByLocation(latitude, longitude, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single hydrated user object given a username
         * @summary By username
         * @param {string} username Username of the user to fetch
         * @param {number} [viewerFid] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userByUsernameV2(username: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.userByUsernameV2(username, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
         * @summary Power user FIDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userPowerLite(options?: RawAxiosRequestConfig): AxiosPromise<UserPowerLiteResponse> {
            return localVarFp.userPowerLite(options).then((request) => request(axios, basePath));
        },
        /**
         * Search for Usernames
         * @summary Search for Usernames
         * @param {string} q 
         * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
         * @param {number} [limit] 
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearch(q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserSearchResponse> {
            return localVarFp.userSearch(q, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Warpcast has deprecated the active badge. Use user/power endpoint instead.
     * @summary Fetch active users
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public activeUsers(limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).activeUsers(limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Removes verification for an eth address for the user \\ (In order to delete verification `signer_uuid` must be approved) 
     * @summary Delete verification
     * @param {RemoveVerificationReqBody} removeVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationDelete(removeVerificationReqBody: RemoveVerificationReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationDelete(removeVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adds verification for an eth address or contract for the user \\ (In order to add verification `signer_uuid` must be approved) 
     * @summary Add verification
     * @param {AddVerificationReqBody} addVerificationReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public farcasterUserVerificationPost(addVerificationReqBody: AddVerificationReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).farcasterUserVerificationPost(addVerificationReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Follow a user \\ (In order to follow a user `signer_uuid` must be approved) 
     * @summary Follow user
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public followUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).followUser(followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches FID to [assign it to new user](https://docs.neynar.com/reference/register-user)
     * @summary Fetch fresh FID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getFreshFid(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).getFreshFid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Lookup a user by custody-address
     * @summary By custody-address
     * @param {string} custodyAddress Custody Address associated with mnemonic
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public lookupUserByCustodyAddress(custodyAddress: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).lookupUserByCustodyAddress(custodyAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users based on Warpcast power badges. Information is updated once a day.
     * @summary Power users
     * @param {number} [viewerFid] 
     * @param {number} [limit] Number of power users to fetch, max 100
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public powerUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).powerUsers(viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register account on farcaster.  **Note:** This API must be called within 10 minutes of the fetch FID API call (i.e., /v2/farcaster/user/fid). Otherwise, Neynar will assign this FID to another available user. 
     * @summary Register new account
     * @param {RegisterUserReqBody} registerUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(registerUserReqBody: RegisterUserReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).registerUser(registerUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unfollow a user \\ (In order to unfollow a user `signer_uuid` must be approved) 
     * @summary Unfollow user
     * @param {FollowReqBody} followReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public unfollowUser(followReqBody: FollowReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).unfollowUser(followReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user profile \\ (In order to update user\'s profile `signer_uuid` must be approved) 
     * @summary Update user profile
     * @param {UpdateUserReqBody} updateUserReqBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserReqBody: UpdateUserReqBody, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserReqBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches information about multiple users based on FIDs
     * @summary By FIDs
     * @param {string} fids Comma separated list of FIDs, up to 100 at a time
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulk(fids: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulk(fids, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches all users based on multiple Ethereum or Solana addresses.  Each farcaster user has a custody Ethereum address and optionally verified Ethereum or Solana addresses. This endpoint returns all users that have any of the given addresses as their custody or verified Ethereum or Solana addresses.  A custody address can be associated with only 1 farcaster user at a time but a verified address can be associated with multiple users. You can pass in Ethereum and Solana addresses, comma separated, in the same request. The response will contain users associated with the given addresses.
     * @summary By Eth or Sol addresses
     * @param {string} addresses Comma separated list of Ethereum addresses, up to 350 at a time
     * @param {string} [addressTypes] Customize which address types the request should search for. This is a comma-separated string that can include the following values: \&#39;custody_address\&#39; and \&#39;verified_address\&#39;. By default api returns both. To select multiple types, use a comma-separated list of these values. 
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userBulkByAddress(addresses: string, addressTypes?: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userBulkByAddress(addresses, addressTypes, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }
    
    /**
    * Fetches a list of users given a location
    * @summary By location
    * @param {number} latitude Latitude of the location
    * @param {number} longitude Longitude of the location
    * @param {number} [viewerFid] FID of the user viewing the feed. Providing this will return a list of users that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
    * @param {number} [limit] Number of results to fetch
    * @param {string} [cursor] Pagination cursor
    * @param {*} [options] Override http request option.
    * @throws {RequiredError}
    * @memberof UserApi
    */
    public userByLocation(latitude: number, longitude: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userByLocation(latitude, longitude, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single hydrated user object given a username
     * @summary By username
     * @param {string} username Username of the user to fetch
     * @param {number} [viewerFid] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userByUsernameV2(username: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userByUsernameV2(username, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches power users and respond in a backwards compatible format to Warpcast\'s deprecated power badge endpoint.
     * @summary Power user FIDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userPowerLite(options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userPowerLite(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for Usernames
     * @summary Search for Usernames
     * @param {string} q 
     * @param {number} [viewerFid] Providing this will return search results that respects this user\&#39;s mutes and blocks and includes &#x60;viewer_context&#x60;.
     * @param {number} [limit] 
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userSearch(q: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userSearch(q, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}

