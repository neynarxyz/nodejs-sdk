/* tslint:disable */
/* eslint-disable */
/**
 * Farcaster API V1
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AllCastsInThreadResponse
 */
export interface AllCastsInThreadResponse {
    /**
     * 
     * @type {AllCastsInThreadResponseResult}
     * @memberof AllCastsInThreadResponse
     */
    'result': AllCastsInThreadResponseResult;
}
/**
 * 
 * @export
 * @interface AllCastsInThreadResponseResult
 */
export interface AllCastsInThreadResponseResult {
    /**
     * 
     * @type {Array<CastWithInteractions>}
     * @memberof AllCastsInThreadResponseResult
     */
    'casts': Array<CastWithInteractions>;
}
/**
 * 
 * @export
 * @interface Cast
 */
export interface Cast {
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'parentHash': string | null;
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'parentUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'threadHash': string;
    /**
     * 
     * @type {CastParentAuthor}
     * @memberof Cast
     */
    'parentAuthor': CastParentAuthor;
    /**
     * 
     * @type {Array<User>}
     * @memberof Cast
     */
    'mentionedProfiles': Array<User>;
    /**
     * 
     * @type {CastAuthor}
     * @memberof Cast
     */
    'author': CastAuthor;
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof Cast
     */
    'timestamp': string;
    /**
     * 
     * @type {Array<EmbedUrl>}
     * @memberof Cast
     */
    'embeds': Array<EmbedUrl>;
    /**
     * 
     * @type {CastType}
     * @memberof Cast
     */
    'type'?: CastType;
}


/**
 * @type CastAuthor
 * @export
 */
export type CastAuthor = CastAuthorOneOf | User;

/**
 * 
 * @export
 * @interface CastAuthorOneOf
 */
export interface CastAuthorOneOf {
    /**
     * 
     * @type {string}
     * @memberof CastAuthorOneOf
     */
    'fid': string;
}
/**
 * 
 * @export
 * @interface CastLikesResponse
 */
export interface CastLikesResponse {
    /**
     * 
     * @type {CastLikesResponseResult}
     * @memberof CastLikesResponse
     */
    'result': CastLikesResponseResult;
}
/**
 * 
 * @export
 * @interface CastLikesResponseResult
 */
export interface CastLikesResponseResult {
    /**
     * 
     * @type {Array<Reaction>}
     * @memberof CastLikesResponseResult
     */
    'likes': Array<Reaction>;
    /**
     * 
     * @type {NextCursor}
     * @memberof CastLikesResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface CastParentAuthor
 */
export interface CastParentAuthor {
    /**
     * 
     * @type {string}
     * @memberof CastParentAuthor
     */
    'fid': string | null;
}
/**
 * 
 * @export
 * @interface CastReactionsResponse
 */
export interface CastReactionsResponse {
    /**
     * 
     * @type {CastReactionsResponseResult}
     * @memberof CastReactionsResponse
     */
    'result': CastReactionsResponseResult;
}
/**
 * 
 * @export
 * @interface CastReactionsResponseResult
 */
export interface CastReactionsResponseResult {
    /**
     * 
     * @type {Array<Reaction>}
     * @memberof CastReactionsResponseResult
     */
    'casts': Array<Reaction>;
    /**
     * 
     * @type {NextCursor}
     * @memberof CastReactionsResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface CastRecasterResponse
 */
export interface CastRecasterResponse {
    /**
     * 
     * @type {CastRecasterResponseResult}
     * @memberof CastRecasterResponse
     */
    'result': CastRecasterResponseResult;
}
/**
 * 
 * @export
 * @interface CastRecasterResponseResult
 */
export interface CastRecasterResponseResult {
    /**
     * 
     * @type {Array<Recaster>}
     * @memberof CastRecasterResponseResult
     */
    'users': Array<Recaster>;
    /**
     * 
     * @type {NextCursor}
     * @memberof CastRecasterResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface CastResponse
 */
export interface CastResponse {
    /**
     * 
     * @type {CastResponseResult}
     * @memberof CastResponse
     */
    'result': CastResponseResult;
}
/**
 * 
 * @export
 * @interface CastResponseResult
 */
export interface CastResponseResult {
    /**
     * 
     * @type {CastWithInteractions}
     * @memberof CastResponseResult
     */
    'cast': CastWithInteractions;
}
/**
 * The notification type of a cast. 
 * @export
 * @enum {string}
 */

export const CastType = {
    Mention: 'cast-mention',
    Reply: 'cast-reply'
} as const;

export type CastType = typeof CastType[keyof typeof CastType];


/**
 * 
 * @export
 * @interface CastWithInteractions
 */
export interface CastWithInteractions {
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'parentHash': string | null;
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'parentUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'threadHash': string;
    /**
     * 
     * @type {CastParentAuthor}
     * @memberof CastWithInteractions
     */
    'parentAuthor': CastParentAuthor;
    /**
     * 
     * @type {Array<User>}
     * @memberof CastWithInteractions
     */
    'mentionedProfiles': Array<User>;
    /**
     * 
     * @type {CastAuthor}
     * @memberof CastWithInteractions
     */
    'author': CastAuthor;
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof CastWithInteractions
     */
    'timestamp': string;
    /**
     * 
     * @type {Array<EmbedUrl>}
     * @memberof CastWithInteractions
     */
    'embeds': Array<EmbedUrl>;
    /**
     * 
     * @type {CastType}
     * @memberof CastWithInteractions
     */
    'type'?: CastType;
    /**
     * 
     * @type {CastWithInteractionsReactions}
     * @memberof CastWithInteractions
     */
    'reactions': CastWithInteractionsReactions;
    /**
     * 
     * @type {CastWithInteractionsRecasts}
     * @memberof CastWithInteractions
     */
    'recasts': CastWithInteractionsRecasts;
    /**
     * 
     * @type {Array<string>}
     * @memberof CastWithInteractions
     */
    'recasters': Array<string>;
    /**
     * 
     * @type {ViewerContext}
     * @memberof CastWithInteractions
     */
    'viewerContext'?: ViewerContext;
    /**
     * 
     * @type {CastWithInteractionsReplies}
     * @memberof CastWithInteractions
     */
    'replies': CastWithInteractionsReplies;
}


/**
 * 
 * @export
 * @interface CastWithInteractionsReactions
 */
export interface CastWithInteractionsReactions {
    /**
     * 
     * @type {number}
     * @memberof CastWithInteractionsReactions
     */
    'count': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CastWithInteractionsReactions
     */
    'fids': Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof CastWithInteractionsReactions
     */
    'fnames': Array<string>;
}
/**
 * 
 * @export
 * @interface CastWithInteractionsRecasts
 */
export interface CastWithInteractionsRecasts {
    /**
     * 
     * @type {number}
     * @memberof CastWithInteractionsRecasts
     */
    'count': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CastWithInteractionsRecasts
     */
    'fids': Array<number>;
}
/**
 * 
 * @export
 * @interface CastWithInteractionsReplies
 */
export interface CastWithInteractionsReplies {
    /**
     * 
     * @type {number}
     * @memberof CastWithInteractionsReplies
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface CastsResponse
 */
export interface CastsResponse {
    /**
     * 
     * @type {CastsResponseResult}
     * @memberof CastsResponse
     */
    'result': CastsResponseResult;
}
/**
 * 
 * @export
 * @interface CastsResponseResult
 */
export interface CastsResponseResult {
    /**
     * 
     * @type {Array<CastWithInteractions>}
     * @memberof CastsResponseResult
     */
    'casts': Array<CastWithInteractions>;
    /**
     * 
     * @type {NextCursor}
     * @memberof CastsResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface CustodyAddressResponse
 */
export interface CustodyAddressResponse {
    /**
     * 
     * @type {CustodyAddressResponseResult}
     * @memberof CustodyAddressResponse
     */
    'result': CustodyAddressResponseResult;
}
/**
 * 
 * @export
 * @interface CustodyAddressResponseResult
 */
export interface CustodyAddressResponseResult {
    /**
     * User identifier (unsigned integer)
     * @type {number}
     * @memberof CustodyAddressResponseResult
     */
    'fid': number;
    /**
     * 
     * @type {string}
     * @memberof CustodyAddressResponseResult
     */
    'custodyAddress': string | null;
}
/**
 * 
 * @export
 * @interface EmbedUrl
 */
export interface EmbedUrl {
    /**
     * 
     * @type {string}
     * @memberof EmbedUrl
     */
    'url': string;
}
/**
 * Returns ErrorRes metadata
 * @export
 * @interface ErrorRes
 */
export interface ErrorRes {
    /**
     * 
     * @type {string}
     * @memberof ErrorRes
     */
    'code'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorRes
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ErrorRes
     */
    'property'?: string;
}
/**
 * 
 * @export
 * @interface FollowResponse
 */
export interface FollowResponse {
    /**
     * 
     * @type {FollowResponseResult}
     * @memberof FollowResponse
     */
    'result': FollowResponseResult;
}
/**
 * 
 * @export
 * @interface FollowResponseResult
 */
export interface FollowResponseResult {
    /**
     * 
     * @type {Array<FollowResponseUser>}
     * @memberof FollowResponseResult
     */
    'users': Array<FollowResponseUser>;
    /**
     * 
     * @type {NextCursor}
     * @memberof FollowResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface FollowResponseUser
 */
export interface FollowResponseUser {
    /**
     * User identifier (unsigned integer)
     * @type {number}
     * @memberof FollowResponseUser
     */
    'fid': number;
    /**
     * The username of the user.
     * @type {string}
     * @memberof FollowResponseUser
     */
    'username': string;
    /**
     * Custody Address of the user.
     * @type {string}
     * @memberof FollowResponseUser
     */
    'custodyAddress': string;
    /**
     * The display of the reactor.
     * @type {string}
     * @memberof FollowResponseUser
     */
    'displayName': string;
    /**
     * 
     * @type {UserPfp}
     * @memberof FollowResponseUser
     */
    'pfp': UserPfp;
    /**
     * 
     * @type {UserProfile}
     * @memberof FollowResponseUser
     */
    'profile': UserProfile;
    /**
     * The number of followers the user has.
     * @type {number}
     * @memberof FollowResponseUser
     */
    'followerCount': number;
    /**
     * The number of users the user is following.
     * @type {number}
     * @memberof FollowResponseUser
     */
    'followingCount': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof FollowResponseUser
     */
    'verifications': Array<string>;
    /**
     * 
     * @type {ViewerContext}
     * @memberof FollowResponseUser
     */
    'viewerContext'?: ViewerContext;
    /**
     * 
     * @type {string}
     * @memberof FollowResponseUser
     */
    'timestamp': string;
}
/**
 * 
 * @export
 * @interface MentionsAndRepliesResponse
 */
export interface MentionsAndRepliesResponse {
    /**
     * 
     * @type {MentionsAndRepliesResponseResult}
     * @memberof MentionsAndRepliesResponse
     */
    'result': MentionsAndRepliesResponseResult;
}
/**
 * 
 * @export
 * @interface MentionsAndRepliesResponseResult
 */
export interface MentionsAndRepliesResponseResult {
    /**
     * 
     * @type {Array<CastWithInteractions>}
     * @memberof MentionsAndRepliesResponseResult
     */
    'notifications': Array<CastWithInteractions>;
    /**
     * 
     * @type {NextCursor}
     * @memberof MentionsAndRepliesResponseResult
     */
    'next': NextCursor;
}
/**
 * Returns next cursor
 * @export
 * @interface NextCursor
 */
export interface NextCursor {
    /**
     * 
     * @type {string}
     * @memberof NextCursor
     */
    'cursor': string | null;
}
/**
 * 
 * @export
 * @interface Reaction
 */
export interface Reaction {
    /**
     * 
     * @type {ReactionType}
     * @memberof Reaction
     */
    'type': ReactionType;
    /**
     * Ethereum address
     * @type {string}
     * @memberof Reaction
     */
    'hash': string;
    /**
     * 
     * @type {Reactor}
     * @memberof Reaction
     */
    'reactor': Reactor;
    /**
     * 
     * @type {string}
     * @memberof Reaction
     */
    'timestamp': string;
    /**
     * Cast Hash
     * @type {string}
     * @memberof Reaction
     */
    'castHash': string;
}


/**
 * The reaction type of a cast.   - like: Cast is being liked by a user.   - recast: Cast is being recasted by a user. 
 * @export
 * @enum {string}
 */

export const ReactionType = {
    Like: 'like',
    Recast: 'recast'
} as const;

export type ReactionType = typeof ReactionType[keyof typeof ReactionType];


/**
 * Reaction of a user (either like or recast), along with its associated cast
 * @export
 * @interface ReactionWithCastMeta
 */
export interface ReactionWithCastMeta {
    /**
     * 
     * @type {ReactionWithCastMetaReaction}
     * @memberof ReactionWithCastMeta
     */
    'reaction': ReactionWithCastMetaReaction;
    /**
     * 
     * @type {ReactionWithCastMetaCast}
     * @memberof ReactionWithCastMeta
     */
    'cast'?: ReactionWithCastMetaCast;
    /**
     * 
     * @type {User}
     * @memberof ReactionWithCastMeta
     */
    'cast_author'?: User;
}
/**
 * 
 * @export
 * @interface ReactionWithCastMetaCast
 */
export interface ReactionWithCastMetaCast {
    /**
     * User identifier (unsigned integer)
     * @type {number}
     * @memberof ReactionWithCastMetaCast
     */
    'cast_fid': number;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaCast
     */
    'cast_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaCast
     */
    'cast_text': string;
    /**
     * 
     * @type {Array<EmbedUrl>}
     * @memberof ReactionWithCastMetaCast
     */
    'cast_embeds': Array<EmbedUrl>;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaCast
     */
    'cast_timestamp': string;
}
/**
 * 
 * @export
 * @interface ReactionWithCastMetaReaction
 */
export interface ReactionWithCastMetaReaction {
    /**
     * User identifier (unsigned integer)
     * @type {number}
     * @memberof ReactionWithCastMetaReaction
     */
    'reactor_fid': number;
    /**
     * 
     * @type {ReactionType}
     * @memberof ReactionWithCastMetaReaction
     */
    'reaction_type': ReactionType;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaReaction
     */
    'reaction_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaReaction
     */
    'reaction_target_hash': string;
    /**
     * 
     * @type {string}
     * @memberof ReactionWithCastMetaReaction
     */
    'reaction_timestamp': string;
}


/**
 * 
 * @export
 * @interface ReactionsAndRecastsNotification
 */
export interface ReactionsAndRecastsNotification {
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'parentHash': string | null;
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'parentUrl': string | null;
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'threadHash': string;
    /**
     * 
     * @type {CastParentAuthor}
     * @memberof ReactionsAndRecastsNotification
     */
    'parentAuthor': CastParentAuthor;
    /**
     * 
     * @type {Array<User>}
     * @memberof ReactionsAndRecastsNotification
     */
    'mentionedProfiles': Array<User>;
    /**
     * 
     * @type {CastAuthor}
     * @memberof ReactionsAndRecastsNotification
     */
    'author': CastAuthor;
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'text': string;
    /**
     * 
     * @type {string}
     * @memberof ReactionsAndRecastsNotification
     */
    'timestamp': string;
    /**
     * 
     * @type {Array<EmbedUrl>}
     * @memberof ReactionsAndRecastsNotification
     */
    'embeds': Array<EmbedUrl>;
    /**
     * 
     * @type {CastType}
     * @memberof ReactionsAndRecastsNotification
     */
    'type'?: CastType;
    /**
     * 
     * @type {Array<User>}
     * @memberof ReactionsAndRecastsNotification
     */
    'reactors'?: Array<User>;
    /**
     * 
     * @type {ReactionType}
     * @memberof ReactionsAndRecastsNotification
     */
    'reactionType'?: ReactionType;
}


/**
 * 
 * @export
 * @interface ReactionsAndRecastsResponse
 */
export interface ReactionsAndRecastsResponse {
    /**
     * 
     * @type {ReactionsAndRecastsResponseResult}
     * @memberof ReactionsAndRecastsResponse
     */
    'result': ReactionsAndRecastsResponseResult;
}
/**
 * 
 * @export
 * @interface ReactionsAndRecastsResponseResult
 */
export interface ReactionsAndRecastsResponseResult {
    /**
     * 
     * @type {Array<ReactionsAndRecastsNotification>}
     * @memberof ReactionsAndRecastsResponseResult
     */
    'notifications': Array<ReactionsAndRecastsNotification>;
    /**
     * 
     * @type {NextCursor}
     * @memberof ReactionsAndRecastsResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface Reactor
 */
export interface Reactor {
    /**
     * The unique identifier of the reactor.
     * @type {number}
     * @memberof Reactor
     */
    'fid': number;
    /**
     * The username of the reactor.
     * @type {string}
     * @memberof Reactor
     */
    'username': string;
    /**
     * The display name of the reactor.
     * @type {string}
     * @memberof Reactor
     */
    'displayName': string;
    /**
     * 
     * @type {ReactorPfp}
     * @memberof Reactor
     */
    'pfp': ReactorPfp;
    /**
     * The number of followers the reactor has.
     * @type {number}
     * @memberof Reactor
     */
    'followerCount': number;
    /**
     * The number of users the reactor is following.
     * @type {number}
     * @memberof Reactor
     */
    'followingCount': number;
    /**
     * 
     * @type {ReactorViewerContext}
     * @memberof Reactor
     */
    'viewerContext'?: ReactorViewerContext;
}
/**
 * 
 * @export
 * @interface ReactorPfp
 */
export interface ReactorPfp {
    /**
     * The URL of the reactor\'s profile picture.
     * @type {string}
     * @memberof ReactorPfp
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ReactorViewerContext
 */
export interface ReactorViewerContext {
    /**
     * Indicates if the viewer is following the reactor.
     * @type {boolean}
     * @memberof ReactorViewerContext
     */
    'following': boolean;
    /**
     * Indicates if the reactor is followed by the viewer.
     * @type {boolean}
     * @memberof ReactorViewerContext
     */
    'followedBy': boolean;
}
/**
 * 
 * @export
 * @interface Recaster
 */
export interface Recaster {
    /**
     * The unique identifier of the recaster.
     * @type {number}
     * @memberof Recaster
     */
    'fid': number;
    /**
     * The username of the recaster.
     * @type {string}
     * @memberof Recaster
     */
    'username': string;
    /**
     * The display name of the recaster.
     * @type {string}
     * @memberof Recaster
     */
    'displayName': string;
    /**
     * 
     * @type {RecasterPfp}
     * @memberof Recaster
     */
    'pfp': RecasterPfp;
    /**
     * 
     * @type {RecasterProfile}
     * @memberof Recaster
     */
    'profile': RecasterProfile;
    /**
     * The number of followers the recaster has.
     * @type {number}
     * @memberof Recaster
     */
    'followerCount': number;
    /**
     * The number of users the recaster is following.
     * @type {number}
     * @memberof Recaster
     */
    'followingCount': number;
    /**
     * 
     * @type {string}
     * @memberof Recaster
     */
    'timestamp': string;
    /**
     * 
     * @type {RecasterViewerContext}
     * @memberof Recaster
     */
    'viewerContext'?: RecasterViewerContext;
}
/**
 * 
 * @export
 * @interface RecasterPfp
 */
export interface RecasterPfp {
    /**
     * The URL of the recaster\'s profile picture.
     * @type {string}
     * @memberof RecasterPfp
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface RecasterProfile
 */
export interface RecasterProfile {
    /**
     * 
     * @type {RecasterProfileBio}
     * @memberof RecasterProfile
     */
    'bio': RecasterProfileBio;
}
/**
 * 
 * @export
 * @interface RecasterProfileBio
 */
export interface RecasterProfileBio {
    /**
     * 
     * @type {string}
     * @memberof RecasterProfileBio
     */
    'text': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RecasterProfileBio
     */
    'mentions': Array<string>;
}
/**
 * 
 * @export
 * @interface RecasterViewerContext
 */
export interface RecasterViewerContext {
    /**
     * Indicates if the viewer is following the recaster.
     * @type {boolean}
     * @memberof RecasterViewerContext
     */
    'following': boolean;
    /**
     * Indicates if the recaster is followed by the viewer.
     * @type {boolean}
     * @memberof RecasterViewerContext
     */
    'followedBy': boolean;
}
/**
 * 
 * @export
 * @interface RecentCastsResponse
 */
export interface RecentCastsResponse {
    /**
     * 
     * @type {CastsResponseResult}
     * @memberof RecentCastsResponse
     */
    'result': CastsResponseResult;
}
/**
 * 
 * @export
 * @interface RecentUsersResponse
 */
export interface RecentUsersResponse {
    /**
     * 
     * @type {RecentUsersResponseResult}
     * @memberof RecentUsersResponse
     */
    'result': RecentUsersResponseResult;
}
/**
 * 
 * @export
 * @interface RecentUsersResponseResult
 */
export interface RecentUsersResponseResult {
    /**
     * 
     * @type {Array<User>}
     * @memberof RecentUsersResponseResult
     */
    'users': Array<User>;
    /**
     * 
     * @type {NextCursor}
     * @memberof RecentUsersResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * User identifier (unsigned integer)
     * @type {number}
     * @memberof User
     */
    'fid': number;
    /**
     * The username of the user.
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * Custody Address of the user.
     * @type {string}
     * @memberof User
     */
    'custodyAddress': string;
    /**
     * The display of the reactor.
     * @type {string}
     * @memberof User
     */
    'displayName': string;
    /**
     * 
     * @type {UserPfp}
     * @memberof User
     */
    'pfp': UserPfp;
    /**
     * 
     * @type {UserProfile}
     * @memberof User
     */
    'profile': UserProfile;
    /**
     * The number of followers the user has.
     * @type {number}
     * @memberof User
     */
    'followerCount': number;
    /**
     * The number of users the user is following.
     * @type {number}
     * @memberof User
     */
    'followingCount': number;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'verifications': Array<string>;
    /**
     * 
     * @type {ViewerContext}
     * @memberof User
     */
    'viewerContext'?: ViewerContext;
}
/**
 * 
 * @export
 * @interface UserCastLikeResponse
 */
export interface UserCastLikeResponse {
    /**
     * 
     * @type {UserCastLikeResponseResult}
     * @memberof UserCastLikeResponse
     */
    'result': UserCastLikeResponseResult;
}
/**
 * 
 * @export
 * @interface UserCastLikeResponseResult
 */
export interface UserCastLikeResponseResult {
    /**
     * 
     * @type {User}
     * @memberof UserCastLikeResponseResult
     */
    'reactor': User;
    /**
     * 
     * @type {Array<ReactionWithCastMeta>}
     * @memberof UserCastLikeResponseResult
     */
    'likes': Array<ReactionWithCastMeta>;
    /**
     * 
     * @type {NextCursor}
     * @memberof UserCastLikeResponseResult
     */
    'next': NextCursor;
}
/**
 * 
 * @export
 * @interface UserPfp
 */
export interface UserPfp {
    /**
     * The URL of the user\'s profile picture.
     * @type {string}
     * @memberof UserPfp
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface UserProfile
 */
export interface UserProfile {
    /**
     * 
     * @type {UserProfileBio}
     * @memberof UserProfile
     */
    'bio': UserProfileBio;
}
/**
 * 
 * @export
 * @interface UserProfileBio
 */
export interface UserProfileBio {
    /**
     * 
     * @type {string}
     * @memberof UserProfileBio
     */
    'text': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserProfileBio
     */
    'mentionedProfiles': Array<string>;
}
/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {UserResponseResult}
     * @memberof UserResponse
     */
    'result': UserResponseResult;
}
/**
 * 
 * @export
 * @interface UserResponseResult
 */
export interface UserResponseResult {
    /**
     * 
     * @type {User}
     * @memberof UserResponseResult
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface VerificationResponse
 */
export interface VerificationResponse {
    /**
     * 
     * @type {VerificationResponseResult}
     * @memberof VerificationResponse
     */
    'result': VerificationResponseResult;
}
/**
 * 
 * @export
 * @interface VerificationResponseResult
 */
export interface VerificationResponseResult {
    /**
     * 
     * @type {string}
     * @memberof VerificationResponseResult
     */
    'fid': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationResponseResult
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof VerificationResponseResult
     */
    'display_name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof VerificationResponseResult
     */
    'verifications': Array<string>;
}
/**
 * 
 * @export
 * @interface ViewerContext
 */
export interface ViewerContext {
    /**
     * 
     * @type {boolean}
     * @memberof ViewerContext
     */
    'following': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ViewerContext
     */
    'followedBy': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ViewerContext
     */
    'liked'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ViewerContext
     */
    'recasted'?: boolean;
}

/**
 * CastApi - axios parameter creator
 * @export
 */
export const CastApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Now deprecated, use [v2/cast/conversation](https://docs.neynar.com/reference/cast-conversation). Gets all casts, including root cast and all replies for a given thread hash. No limit the depth of replies.
         * @summary DEPRECATED - Fetch all casts in a given thread hash
         * @param {string} threadHash The hash of the thread to fetch casts from.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        allCastsInThread: async (threadHash: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'threadHash' is not null or undefined
            assertParamExists('allCastsInThread', 'threadHash', threadHash)
            const localVarPath = `/farcaster/all-casts-in-thread`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (threadHash !== undefined) {
                localVarQueryParameter['threadHash'] = threadHash;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated, use [v2/cast](https://docs.neynar.com/reference/cast). Gets information about an individual cast
         * @summary DEPRECATED - Fetch cast for a given hash
         * @param {string} hash Cast hash
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cast: async (hash: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('cast', 'hash', hash)
            const localVarPath = `/farcaster/cast`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (hash !== undefined) {
                localVarQueryParameter['hash'] = hash;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated, use [/v2/farcaster/feed/user/casts](https://docs.neynar.com/reference/feed-user-casts) instead
         * @summary DEPRECATED - Casts by user
         * @param {number} fid FID of a user
         * @param {string} [parentUrl] A cast can be part of a certain channel. The channel is identified by &#x60;parent_url&#x60;. All casts in the channel ladder up to the same parent_url.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        casts: async (fid: number, parentUrl?: string, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('casts', 'fid', fid)
            const localVarPath = `/farcaster/casts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (parentUrl !== undefined) {
                localVarQueryParameter['parent_url'] = parentUrl;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Casts
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentCasts: async (viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/recent-casts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CastApi - functional programming interface
 * @export
 */
export const CastApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CastApiAxiosParamCreator(configuration)
    return {
        /**
         * Now deprecated, use [v2/cast/conversation](https://docs.neynar.com/reference/cast-conversation). Gets all casts, including root cast and all replies for a given thread hash. No limit the depth of replies.
         * @summary DEPRECATED - Fetch all casts in a given thread hash
         * @param {string} threadHash The hash of the thread to fetch casts from.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async allCastsInThread(threadHash: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AllCastsInThreadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.allCastsInThread(threadHash, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CastApi.allCastsInThread']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated, use [v2/cast](https://docs.neynar.com/reference/cast). Gets information about an individual cast
         * @summary DEPRECATED - Fetch cast for a given hash
         * @param {string} hash Cast hash
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async cast(hash: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CastResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cast(hash, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CastApi.cast']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated, use [/v2/farcaster/feed/user/casts](https://docs.neynar.com/reference/feed-user-casts) instead
         * @summary DEPRECATED - Casts by user
         * @param {number} fid FID of a user
         * @param {string} [parentUrl] A cast can be part of a certain channel. The channel is identified by &#x60;parent_url&#x60;. All casts in the channel ladder up to the same parent_url.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async casts(fid: number, parentUrl?: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CastsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.casts(fid, parentUrl, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CastApi.casts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Casts
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentCasts(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentCastsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentCasts(viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CastApi.recentCasts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CastApi - factory interface
 * @export
 */
export const CastApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CastApiFp(configuration)
    return {
        /**
         * Now deprecated, use [v2/cast/conversation](https://docs.neynar.com/reference/cast-conversation). Gets all casts, including root cast and all replies for a given thread hash. No limit the depth of replies.
         * @summary DEPRECATED - Fetch all casts in a given thread hash
         * @param {string} threadHash The hash of the thread to fetch casts from.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        allCastsInThread(threadHash: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<AllCastsInThreadResponse> {
            return localVarFp.allCastsInThread(threadHash, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated, use [v2/cast](https://docs.neynar.com/reference/cast). Gets information about an individual cast
         * @summary DEPRECATED - Fetch cast for a given hash
         * @param {string} hash Cast hash
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cast(hash: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<CastResponse> {
            return localVarFp.cast(hash, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated, use [/v2/farcaster/feed/user/casts](https://docs.neynar.com/reference/feed-user-casts) instead
         * @summary DEPRECATED - Casts by user
         * @param {number} fid FID of a user
         * @param {string} [parentUrl] A cast can be part of a certain channel. The channel is identified by &#x60;parent_url&#x60;. All casts in the channel ladder up to the same parent_url.
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        casts(fid: number, parentUrl?: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<CastsResponse> {
            return localVarFp.casts(fid, parentUrl, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Casts
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 100)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentCasts(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecentCastsResponse> {
            return localVarFp.recentCasts(viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CastApi - object-oriented interface
 * @export
 * @class CastApi
 * @extends {BaseAPI}
 */
export class CastApi extends BaseAPI {
    /**
     * Now deprecated, use [v2/cast/conversation](https://docs.neynar.com/reference/cast-conversation). Gets all casts, including root cast and all replies for a given thread hash. No limit the depth of replies.
     * @summary DEPRECATED - Fetch all casts in a given thread hash
     * @param {string} threadHash The hash of the thread to fetch casts from.
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CastApi
     */
    public allCastsInThread(threadHash: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return CastApiFp(this.configuration).allCastsInThread(threadHash, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated, use [v2/cast](https://docs.neynar.com/reference/cast). Gets information about an individual cast
     * @summary DEPRECATED - Fetch cast for a given hash
     * @param {string} hash Cast hash
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CastApi
     */
    public cast(hash: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return CastApiFp(this.configuration).cast(hash, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated, use [/v2/farcaster/feed/user/casts](https://docs.neynar.com/reference/feed-user-casts) instead
     * @summary DEPRECATED - Casts by user
     * @param {number} fid FID of a user
     * @param {string} [parentUrl] A cast can be part of a certain channel. The channel is identified by &#x60;parent_url&#x60;. All casts in the channel ladder up to the same parent_url.
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 150)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CastApi
     */
    public casts(fid: number, parentUrl?: string, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CastApiFp(this.configuration).casts(fid, parentUrl, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
     * @summary Fetch Recent Casts
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 100)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CastApi
     */
    public recentCasts(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return CastApiFp(this.configuration).recentCasts(viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FollowsApi - axios parameter creator
 * @export
 */
export const FollowsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of users who follow a user in reverse chronological order.
         * @summary Gets all followers for a given FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followers: async (fid: number, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('followers', 'fid', fid)
            const localVarPath = `/farcaster/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a list of users who is following a user in reverse chronological order.
         * @summary Gets all following users of a FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        following: async (fid: number, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('following', 'fid', fid)
            const localVarPath = `/farcaster/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FollowsApi - functional programming interface
 * @export
 */
export const FollowsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FollowsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of users who follow a user in reverse chronological order.
         * @summary Gets all followers for a given FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followers(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followers(fid, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FollowsApi.followers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a list of users who is following a user in reverse chronological order.
         * @summary Gets all following users of a FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async following(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.following(fid, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FollowsApi.following']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FollowsApi - factory interface
 * @export
 */
export const FollowsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FollowsApiFp(configuration)
    return {
        /**
         * Gets a list of users who follow a user in reverse chronological order.
         * @summary Gets all followers for a given FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followers(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<FollowResponse> {
            return localVarFp.followers(fid, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a list of users who is following a user in reverse chronological order.
         * @summary Gets all following users of a FID
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        following(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<FollowResponse> {
            return localVarFp.following(fid, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FollowsApi - object-oriented interface
 * @export
 * @class FollowsApi
 * @extends {BaseAPI}
 */
export class FollowsApi extends BaseAPI {
    /**
     * Gets a list of users who follow a user in reverse chronological order.
     * @summary Gets all followers for a given FID
     * @param {number} fid FID of the user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 150)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public followers(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).followers(fid, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a list of users who is following a user in reverse chronological order.
     * @summary Gets all following users of a FID
     * @param {number} fid FID of the user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 150)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FollowsApi
     */
    public following(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return FollowsApiFp(this.configuration).following(fid, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Gets a list of 15 mentions and replies to the users casts in reverse chronological order
         * @summary Fetch mentions and replies
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mentionsAndReplies: async (fid: number, viewerFid?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('mentionsAndReplies', 'fid', fid)
            const localVarPath = `/farcaster/mentions-and-replies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of reactions and recasts to the userss casts in reverse chronological order
         * @summary Fetch reactions and recasts
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactionsAndRecasts: async (fid: number, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('reactionsAndRecasts', 'fid', fid)
            const localVarPath = `/farcaster/reactions-and-recasts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Gets a list of 15 mentions and replies to the users casts in reverse chronological order
         * @summary Fetch mentions and replies
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mentionsAndReplies(fid: number, viewerFid?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MentionsAndRepliesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mentionsAndReplies(fid, viewerFid, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.mentionsAndReplies']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of reactions and recasts to the userss casts in reverse chronological order
         * @summary Fetch reactions and recasts
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reactionsAndRecasts(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReactionsAndRecastsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reactionsAndRecasts(fid, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.reactionsAndRecasts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * Gets a list of 15 mentions and replies to the users casts in reverse chronological order
         * @summary Fetch mentions and replies
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mentionsAndReplies(fid: number, viewerFid?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<MentionsAndRepliesResponse> {
            return localVarFp.mentionsAndReplies(fid, viewerFid, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of reactions and recasts to the userss casts in reverse chronological order
         * @summary Fetch reactions and recasts
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reactionsAndRecasts(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReactionsAndRecastsResponse> {
            return localVarFp.reactionsAndRecasts(fid, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * Gets a list of 15 mentions and replies to the users casts in reverse chronological order
     * @summary Fetch mentions and replies
     * @param {number} fid FID of a user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public mentionsAndReplies(fid: number, viewerFid?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).mentionsAndReplies(fid, viewerFid, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of reactions and recasts to the userss casts in reverse chronological order
     * @summary Fetch reactions and recasts
     * @param {number} fid FID of a user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 150)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public reactionsAndRecasts(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).reactionsAndRecasts(fid, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), find custody address in user obj. Returns the custody address for a given FID
         * @summary DEPRECATED - Fetch the custody address for a given FID
         * @param {number} fid FID of a user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        custodyAddress: async (fid: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('custodyAddress', 'fid', fid)
            const localVarPath = `/farcaster/custody-address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Users
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 100, max 1000)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentUsers: async (viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/farcaster/recent-users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk). Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by FID
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        user: async (fid: number, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('user', 'fid', fid)
            const localVarPath = `/farcaster/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated, use [v2/user/by_username](https://docs.neynar.com/reference/user-by-username-v2) instead. Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by username
         * @param {string} username Username of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userByUsernameV1: async (username: string, viewerFid?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userByUsernameV1', 'username', username)
            const localVarPath = `/farcaster/user-by-username`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated. use [/v2/reactions/user](https://docs.neynar.com/reference/reactions-user). Fetch all the liked cast of a User
         * @summary DEPRECATED -- Fetch User Cast Likes
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userCastLikes: async (fid: number, viewerFid?: number, limit?: number, cursor?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('userCastLikes', 'fid', fid)
            const localVarPath = `/farcaster/user-cast-likes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }

            if (viewerFid !== undefined) {
                localVarQueryParameter['viewerFid'] = viewerFid;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), find custody address in user obj. Returns the custody address for a given FID
         * @summary DEPRECATED - Fetch the custody address for a given FID
         * @param {number} fid FID of a user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async custodyAddress(fid: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustodyAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.custodyAddress(fid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.custodyAddress']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Users
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 100, max 1000)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recentUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecentUsersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recentUsers(viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.recentUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk). Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by FID
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async user(fid: number, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.user(fid, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.user']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated, use [v2/user/by_username](https://docs.neynar.com/reference/user-by-username-v2) instead. Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by username
         * @param {string} username Username of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userByUsernameV1(username: string, viewerFid?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userByUsernameV1(username, viewerFid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userByUsernameV1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated. use [/v2/reactions/user](https://docs.neynar.com/reference/reactions-user). Fetch all the liked cast of a User
         * @summary DEPRECATED -- Fetch User Cast Likes
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userCastLikes(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCastLikeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userCastLikes(fid, viewerFid, limit, cursor, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserApi.userCastLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), find custody address in user obj. Returns the custody address for a given FID
         * @summary DEPRECATED - Fetch the custody address for a given FID
         * @param {number} fid FID of a user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        custodyAddress(fid: number, options?: RawAxiosRequestConfig): AxiosPromise<CustodyAddressResponse> {
            return localVarFp.custodyAddress(fid, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
         * @summary Fetch Recent Users
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 100, max 1000)
         * @param {string} [cursor] Pagination cursor.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recentUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<RecentUsersResponse> {
            return localVarFp.recentUsers(viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk). Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by FID
         * @param {number} fid FID of a user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        user(fid: number, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.user(fid, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated, use [v2/user/by_username](https://docs.neynar.com/reference/user-by-username-v2) instead. Returns metadata about a specific user
         * @summary DEPRECATED - Fetch User Information by username
         * @param {string} username Username of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userByUsernameV1(username: string, viewerFid?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.userByUsernameV1(username, viewerFid, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated. use [/v2/reactions/user](https://docs.neynar.com/reference/reactions-user). Fetch all the liked cast of a User
         * @summary DEPRECATED -- Fetch User Cast Likes
         * @param {number} fid FID of the user
         * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
         * @param {number} [limit] Number of results to fetch (default 25, max 150)
         * @param {string} [cursor] Pagination cursor
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userCastLikes(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserCastLikeResponse> {
            return localVarFp.userCastLikes(fid, viewerFid, limit, cursor, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), find custody address in user obj. Returns the custody address for a given FID
     * @summary DEPRECATED - Fetch the custody address for a given FID
     * @param {number} fid FID of a user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public custodyAddress(fid: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).custodyAddress(fid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a list of casts from the protocol in reverse chronological order based on timestamp
     * @summary Fetch Recent Users
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 100, max 1000)
     * @param {string} [cursor] Pagination cursor.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public recentUsers(viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).recentUsers(viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk). Returns metadata about a specific user
     * @summary DEPRECATED - Fetch User Information by FID
     * @param {number} fid FID of a user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public user(fid: number, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).user(fid, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated, use [v2/user/by_username](https://docs.neynar.com/reference/user-by-username-v2) instead. Returns metadata about a specific user
     * @summary DEPRECATED - Fetch User Information by username
     * @param {string} username Username of the user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userByUsernameV1(username: string, viewerFid?: number, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userByUsernameV1(username, viewerFid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated. use [/v2/reactions/user](https://docs.neynar.com/reference/reactions-user). Fetch all the liked cast of a User
     * @summary DEPRECATED -- Fetch User Cast Likes
     * @param {number} fid FID of the user
     * @param {number} [viewerFid] FID of the user viewing this information, needed for contextual information.
     * @param {number} [limit] Number of results to fetch (default 25, max 150)
     * @param {string} [cursor] Pagination cursor
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userCastLikes(fid: number, viewerFid?: number, limit?: number, cursor?: string, options?: RawAxiosRequestConfig) {
        return UserApiFp(this.configuration).userCastLikes(fid, viewerFid, limit, cursor, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VerificationApi - axios parameter creator
 * @export
 */
export const VerificationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Now deprecated. Use [v2/user/bulk-by-address](https://docs.neynar.com/reference/user-bulk-by-address). Checks if a given Ethereum address has a Farcaster user associated with it. Note: if an address is associated with multiple users, the API will return the user who most recently published a verification with the address (based on when Warpcast received the proof, not a self-reported timestamp).
         * @summary DEPRECATED - Fetch user for a given ethereum address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userByVerification: async (address: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('userByVerification', 'address', address)
            const localVarPath = `/farcaster/user-by-verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), verifications are in the user object. Fetch all known verifications of a user.
         * @summary DEPRECATED - Fetch verifications for a given FID
         * @param {number} fid FID of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        verifications: async (fid: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fid' is not null or undefined
            assertParamExists('verifications', 'fid', fid)
            const localVarPath = `/farcaster/verifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "x-api-key", configuration)

            if (fid !== undefined) {
                localVarQueryParameter['fid'] = fid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VerificationApi - functional programming interface
 * @export
 */
export const VerificationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VerificationApiAxiosParamCreator(configuration)
    return {
        /**
         * Now deprecated. Use [v2/user/bulk-by-address](https://docs.neynar.com/reference/user-bulk-by-address). Checks if a given Ethereum address has a Farcaster user associated with it. Note: if an address is associated with multiple users, the API will return the user who most recently published a verification with the address (based on when Warpcast received the proof, not a self-reported timestamp).
         * @summary DEPRECATED - Fetch user for a given ethereum address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async userByVerification(address: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userByVerification(address, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.userByVerification']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), verifications are in the user object. Fetch all known verifications of a user.
         * @summary DEPRECATED - Fetch verifications for a given FID
         * @param {number} fid FID of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async verifications(fid: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VerificationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifications(fid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VerificationApi.verifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VerificationApi - factory interface
 * @export
 */
export const VerificationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VerificationApiFp(configuration)
    return {
        /**
         * Now deprecated. Use [v2/user/bulk-by-address](https://docs.neynar.com/reference/user-bulk-by-address). Checks if a given Ethereum address has a Farcaster user associated with it. Note: if an address is associated with multiple users, the API will return the user who most recently published a verification with the address (based on when Warpcast received the proof, not a self-reported timestamp).
         * @summary DEPRECATED - Fetch user for a given ethereum address
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        userByVerification(address: string, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.userByVerification(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), verifications are in the user object. Fetch all known verifications of a user.
         * @summary DEPRECATED - Fetch verifications for a given FID
         * @param {number} fid FID of the user
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        verifications(fid: number, options?: RawAxiosRequestConfig): AxiosPromise<VerificationResponse> {
            return localVarFp.verifications(fid, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VerificationApi - object-oriented interface
 * @export
 * @class VerificationApi
 * @extends {BaseAPI}
 */
export class VerificationApi extends BaseAPI {
    /**
     * Now deprecated. Use [v2/user/bulk-by-address](https://docs.neynar.com/reference/user-bulk-by-address). Checks if a given Ethereum address has a Farcaster user associated with it. Note: if an address is associated with multiple users, the API will return the user who most recently published a verification with the address (based on when Warpcast received the proof, not a self-reported timestamp).
     * @summary DEPRECATED - Fetch user for a given ethereum address
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public userByVerification(address: string, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).userByVerification(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Now deprecated, use [v2/user/bulk](https://docs.neynar.com/reference/user-bulk), verifications are in the user object. Fetch all known verifications of a user.
     * @summary DEPRECATED - Fetch verifications for a given FID
     * @param {number} fid FID of the user
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof VerificationApi
     */
    public verifications(fid: number, options?: RawAxiosRequestConfig) {
        return VerificationApiFp(this.configuration).verifications(fid, options).then((request) => request(this.axios, this.basePath));
    }
}



